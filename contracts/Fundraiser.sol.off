// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
// ----------------------
// Imports
// ----------------------
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
// ----------------------
// Contract
// ----------------------

///@notice This contract lets users create fundraising campaigns, donate Ether, 
/// mark campaigns as completed, and withdraw collected funds
contract Fundraiser is Ownable, ReentrancyGuard, Pausable {
    struct Campaign {
        uint id;                     // Unique campaign ID
        string description;          // Description of the campaign
        uint goal;                   // Target amount in wei
        uint raised;                 // Amount raised so far
        bool completed;              // Whether the campaign is completed
        address payable owner;       // Campaign owner (who created it
    }
    // ----------------------
    // State variables
    // ----------------------

    mapping(uint => Campaign) public campaigns;
    uint public nextId;
    uint public totalRaised;

    //----------------------
    //Error
    //----------------------
    error InvalidGoal();
    error InvalidCampaignId();
    error InvalidDonationAmount();
    error AlreadyCompleted();
    error NotAuthorized();
    error GoalNotReached();
    error NoFundsToWithdraw();

    // ----------------------
    // Events
    // ----------------------

    event CampaignCreated(uint indexed id, address indexed owner, uint goal);
    event DonationReceived(uint indexed id, address indexed from, uint amount);
    event CampaignCompleted(uint indexed id);
    event FundsWithdrawn(uint indexed id, address indexed owner, uint amount);

    // ----------------------
    // Functions
    // ----------------------

    /// @notice Create a new fundraising campaign
    /// @dev The campaign starts active and can receive donations until completed
    /// @param _description Short description of the campaign
    /// @param _goal Target amount in wei


    function createCampaign(
        string memory _description,
        uint _goal
    ) public whenNotPaused {
        if (_goal == 0) revert InvalidGoal();
        Campaign memory newCampaign = Campaign({
            id: nextId,
            description: _description,
            goal: _goal,
            raised: 0,
            completed: false,
            owner: payable(msg.sender)
        });
        campaigns[nextId] = newCampaign;
        emit CampaignCreated(nextId, msg.sender, _goal);
        nextId++;
    }
    function donate(uint _id) external payable whenNotPaused nonReentrant {
        if (_id >= nextId) revert InvalidCampaignId();
        if (campaigns[_id].completed) revert AlreadyCompleted();
        if (msg.value == 0) revert InvalidDonationAmount();
        campaigns[_id].raised += msg.value;
        totalRaised += msg.value;

        emit DonationReceived(_id, msg.sender, msg.value);
    }
    function completeCampaign(uint _id) public whenNotPaused {
        if(_id >= nextId) revert InvalidCampaignId();
        if(msg.sender != campaigns[_id].owner) revert NotAuthorized();
        if(campaigns[_id].raised < campaigns[_id].goal)revert GoalNotReached();
        campaigns[_id].completed = true;
        emit CampaignCompleted(_id);
    }
    function withdraw(uint _id) external nonReentrant  whenNotPaused {
        if(_id >= nextId) revert InvalidCampaignId();
        Campaign storage campaign = campaigns[_id];
        if(!campaign.completed) revert GoalNotReached();
        if(msg.sender != campaigns[_id].owner) revert NotAuthorized();
        if(campaign.raised == 0) revert NoFundsToWithdraw();
        uint amount = campaign.raised;
        campaign.raised = 0;
        campaign.owner.transfer(amount);
        emit FundsWithdrawn(_id, campaign.owner, amount);
    }
    function pause() external onlyOwner {
        _pause();
    }
    function unpause() external onlyOwner {
        _unpause();
    };
}
